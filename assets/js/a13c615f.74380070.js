"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9881],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>y});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(n),y=a,h=u["".concat(p,".").concat(y)]||u[y]||d[y]||i;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4624:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:10},o="Abstract Types",s={unversionedId:"graphql-schema-types/abstract-types",id:"graphql-schema-types/abstract-types",title:"Abstract Types",description:"Abstract types like Interfaces and Unions, require type resolution of its variants on execution. For that, we provide a couple of tools explained in the following sections. You can read the code that executes the following logic in package:leto's GraphQL.resolveAbstractType method.",source:"@site/docs/graphql-schema-types/abstract-types.md",sourceDirName:"graphql-schema-types",slug:"/graphql-schema-types/abstract-types",permalink:"/leto/docs/graphql-schema-types/abstract-types",draft:!1,editUrl:"https://github.com/juancastillo0/leto/edit/main/README.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Lists",permalink:"/leto/docs/graphql-schema-types/lists"},next:{title:"Advanced Types",permalink:"/leto/docs/graphql-schema-types/advanced-types"}},p={},l=[{value:"resolveType",id:"resolvetype",level:3},{value:"Generics",id:"generics",level:3},{value:"isTypeOf",id:"istypeof",level:3},{value:"__typename",id:"__typename",level:3},{value:"Serialize and validate",id:"serialize-and-validate",level:3}],c={toc:l};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"abstract-types"},"Abstract Types"),(0,a.kt)("p",null,"Abstract types like Interfaces and Unions, require type resolution of its variants on execution. For that, we provide a couple of tools explained in the following sections. You can read the code that executes the following logic in package:leto's ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQL.resolveAbstractType")," method."),(0,a.kt)("h3",{id:"resolvetype"},"resolveType"),(0,a.kt)("p",null,"A parameter of Interface and Union types is a function with the signature: ",(0,a.kt)("inlineCode",{parentName:"p"},"String Function(Object result, T abstractType, ResolveObjectCtx ctx)"),". Given a resolved result, the abstract type itself and the ObjectCtx, return the name of the type associated with the result value."),(0,a.kt)("h3",{id:"generics"},"Generics"),(0,a.kt)("p",null,"We compare the resolved result's Dart type with the possible types generic type parameter, if there is only one match (withing the possible types), that will be the resolved type. This happens very often, specially with code generation or when providing a distinct class for each ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType"),"."),(0,a.kt)("p",null,"This can't be used with Union types which are wrappers over the inner types (like ",(0,a.kt)("inlineCode",{parentName:"p"},"Result<V, E>")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Either<L, R>"),"), since generic type of the possible types (",(0,a.kt)("inlineCode",{parentName:"p"},"V")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"E"),") will not match the wrapper type (",(0,a.kt)("inlineCode",{parentName:"p"},"Result"),"). For this cases you will need to provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"resolveType")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"extractInner")," callbacks. With freezed-like unions you don't have to do that since the variants extend the union type."),(0,a.kt)("h3",{id:"istypeof"},"isTypeOf"),(0,a.kt)("p",null,"If any of the previous fail, you can provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"isTypeOf")," callback for objects, which determine whether a given value is an instance of that ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType"),"."),(0,a.kt)("h3",{id:"__typename"},"_","_","typename"),(0,a.kt)("p",null,"If the resolved result is a ",(0,a.kt)("inlineCode",{parentName:"p"},"Map"),' and contains a key "',"_","_",'typename", we will use it to resolve the type by comparing it with possible types names. If there is a match, we use the matched type in the next steps of execution.'),(0,a.kt)("h3",{id:"serialize-and-validate"},"Serialize and validate"))}d.isMDXComponent=!0}}]);