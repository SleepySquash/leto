"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1634],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),h=d(n),u=o,m=h["".concat(s,".").concat(u)]||h[u]||p[u]||i;return n?a.createElement(m,l(l({ref:t},c),{},{components:n})):a.createElement(m,l({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=h;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,l[1]=r;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1639:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:9},l="Solving the N+1 problem",r={unversionedId:"main/solving-the-n+1-problem",id:"main/solving-the-n+1-problem",title:"Solving the N+1 problem",description:"When fetching nested fields, a specific resolvers could be executed multiple times for each request since the parent object will execute it for all its children. This may pose a problem when the resolver has to do non-trivial work for each execution. For example, retrieving a row from a database. To solve this problem, Leto provides you with two tools: LookAhead and DataLoader.",source:"@site/docs/main/solving-the-n+1-problem.md",sourceDirName:"main",slug:"/main/solving-the-n+1-problem",permalink:"/leto/docs/main/solving-the-n+1-problem",draft:!1,editUrl:"https://github.com/juancastillo0/leto/edit/main/README.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Miscellaneous",permalink:"/leto/docs/main/miscellaneous"},next:{title:"Extensions",permalink:"/leto/docs/main/extensions"}},s={},d=[{value:"LookAhead (Eager loading)",id:"lookahead-eager-loading",level:2},{value:"DataLoader (Batching)",id:"dataloader-batching",level:2},{value:"Combining LookAhead with DataLoader",id:"combining-lookahead-with-dataloader",level:2}],c={toc:d};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"solving-the-n1-problem"},"Solving the N+1 problem"),(0,o.kt)("p",null,"When fetching nested fields, a specific resolvers could be executed multiple times for each request since the parent object will execute it for all its children. This may pose a problem when the resolver has to do non-trivial work for each execution. For example, retrieving a row from a database. To solve this problem, Leto provides you with two tools: LookAhead and DataLoader."),(0,o.kt)("h2",{id:"lookahead-eager-loading"},"LookAhead (Eager loading)"),(0,o.kt)("p",null,"You can mitigate the N+1 problem by fetching all the necessary information from the parent's resolver so that when the nested fields are executed they just return the previously fetch items. This would prevent all SQL queries for nested fields since the parent resolver has all the information about the selected nested fields and can use this to execute a request that fetches the necessary columns or joins."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"@GraphQLClass()\nclass Model {\n    final String id;\n    final String name;\n    final NestedModel? nested;\n\n    const Model(this.id, this.name, this.nested);\n}\n\n@GraphQLClass()\nclass NestedModel {\n    final String id;\n    final String name;\n\n    const NestedModel(this.id, this.name);\n}\n\nfinal modelRepo = RefWithDefault.global(\n    (GlobalsHolder scope) => ModelRepo();\n);\n\nclass ModelRepo {\n    List<Model> getModels({bool withNested = false}) {\n        // request the database\n        // if `withNested` = true, join with the `nestedModel` table\n        throw Unimplemented();\n    }\n}\n\n@Query()\nFutureOr<List<Model>> getModels(Ctx ctx) {\n    final PossibleSelections lookahead = ctx.lookahead();\n    assert(!lookahead.isUnion);\n    final PossibleSelectionsObject lookaheadObj = lookahead.asObject;\n    final withNested = lookaheadObj.contains('nested');\n\n    final ModelRepo repo = modelRepo.get(ctx);\n    return repo.getModels(withNested: withNested);\n}\n\n")),(0,o.kt)("p",null,"With this implementation and given the following queries:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"query getModelsWithNested {\n  getModels {\n    id\n    name\n    nested {\n      id\n      name\n    }\n  }\n}\n\nquery getModelsBase {\n  getModels {\n    id\n    name\n  }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ModelRepo.getModels")," will receive ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"withNested")," param for the ",(0,o.kt)("inlineCode",{parentName:"p"},"getModelsWithNested")," query since ",(0,o.kt)("inlineCode",{parentName:"p"},"lookaheadObj.contains('nested')")," will be ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". On the other hand, the ",(0,o.kt)("inlineCode",{parentName:"p"},"withNested")," param will be ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," for the ",(0,o.kt)("inlineCode",{parentName:"p"},"getModelsBase"),' query since the "nested" field was not selected.'),(0,o.kt)("p",null,"In this way, ",(0,o.kt)("inlineCode",{parentName:"p"},"ModelRepo.getModels")," knows what nested fields it should return. It could add additional joins in a SQL query, for example."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PossibleSelections")," class has the information about all the nested selected fields when the type of the field is a Composite Type (Object, Interface or Union). When it's an Union, it will provide a map from the type name Object variants to the given variant selections. The @skip and @include directives are already taken into account. You can read more about the ",(0,o.kt)("inlineCode",{parentName:"p"},"PossibleSelections")," class in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/juancastillo0/leto/blob/main/leto_schema/lib/src/req_ctx.dart"},"source code"),"."),(0,o.kt)("h2",{id:"dataloader-batching"},"DataLoader (Batching)"),(0,o.kt)("p",null,"The code in Leto is a port of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/graphql/dataloader"},"graphql/dataloader"),"."),(0,o.kt)("p",null,"An easier to implement but probably less performant way of solving the N+1 problem is by using a ",(0,o.kt)("inlineCode",{parentName:"p"},"DataLoader"),". It allows you to batch multiple requests and execute the complete batch in a single function call."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"\n@GraphQLClass()\nclass Model {\n    final String id;\n    final String name;\n    final int nestedId;\n\n    const Model(this.id, this.name, this.nestedId);\n\n    NestedModel nested(Ctx ctx) {\n        return modelNestedRepo.get(ctx).getNestedModel(nestedId);\n    }\n}\n\nclass NestedModelRepo {\n\n  late final dataLoader = DataLoader.unmapped<String, NestedModel>(getNestedModelsFromIds);\n\n  Future<List<NestedModel>> getNestedModel(String id) {\n    // Batch the id, eventually `dataLoader` will execute\n    // `getNestedModelsFromIds` with a list of batched ids\n    return dataLoader.load(id);\n  }\n\n  Future<List<NestedModel>> getNestedModelsFromIds(List<String> ids) {\n      // Multiple calls to `Model.nested` will be batched and\n      // all ids will be passed in the `ids` argument\n\n      // request the database\n      final List<NestedModel> models = throw Unimplemented();\n\n      // Make a map from id to model instance\n      final Map<String, NestedModel> modelsMap = models.fold(\n        {}, (map, model) => map..[model.id] = model\n      );\n      // Return the models in the same order as the `ids` argument\n      return List.of(ids.map((id) => modelsMap[id]!));\n  }\n}\n\nfinal modelNestedRepo = RefWithDefault.scoped(\n    (scope) => NestedModelRepo()\n);\n\n\n@Query()\nList<Model> getModels(Ctx ctx) {\n    return modelRepo.get(ctx).getModels();\n}\n\n")),(0,o.kt)("p",null,"The DataLoader has some options for configuring it. For example you can specify the maximum size of the batch (default: ",(0,o.kt)("inlineCode",{parentName:"p"},"2^53")," or the maximum javascript integer), whether to batch requests or not (default: ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),") and provide a custom batch schedule function, by default it will use ",(0,o.kt)("inlineCode",{parentName:"p"},"Future.delayed(Duration.zero, executeBatch)"),"."),(0,o.kt)("p",null,"You can also configure caching by providing a custom cache implementation, a custom function that maps the key passed to ",(0,o.kt)("inlineCode",{parentName:"p"},"DataLoader.load")," to the cache's key or disabling caching in the DataLoader."),(0,o.kt)("h2",{id:"combining-lookahead-with-dataloader"},"Combining LookAhead with DataLoader"),(0,o.kt)("p",null,"You can use both, LookAhead and DataLoader at the same time. The keys provided to the ",(0,o.kt)("inlineCode",{parentName:"p"},"DataLoader.load")," function can be anything, so you could send the ",(0,o.kt)("inlineCode",{parentName:"p"},"PossibleSelection")," information, for example."))}p.isMDXComponent=!0}}]);